<!DOCTYPE html>
<html>
	<head>
		<title>What?</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width">
		<link rel="stylesheet" type="text/css" href="index.css">
	</head>
	<body>
		<div id="content">

			<input type="file" id="video-file-selector">

			<video id="video-player" autoplay loop></video>

			<div id="video-controls">
				<input type="range" id="video-seek-bar" value="0" step="0.00001" class="slider">
				<div id="audio-peaks">
				</div>
			</div>
		</div>
		
		<script src="filesaver/FileSaver.js"></script>
		<script>
			document.getElementById("video-seek-bar").oninput = function()
			{
				const player = document.getElementById("video-player");
				player.currentTime = (player.duration * (this.value / 100))
			}

			document.getElementById("video-file-selector").onchange = async function()
			{
				const rawAudio = await get_raw_audio(this.files[0]);
				const audioPeaks = find_audio_peaks(rawAudio.channels[0]);
				
				document.getElementById("video-player").setAttribute("src", URL.createObjectURL(this.files[0]));
				document.getElementById("video-player").setAttribute("type", this.files[0].type);

			//	render_peaks_into_canvas(audioPeaks, rawAudio.channels[0].length);

				/*
				const peaks = find_audio_peaks(rawAudio.channels[0]);
				peaks.forEach(peak=>
				{
					console.log(peak.idx / rawAudio.sampleRate);
				});
				*/
			};

			function update_seek_bar_position()
			{
				const player = document.getElementById("video-player");

				if (!player.paused)
				{
					document.getElementById("video-seek-bar").value = ((player.currentTime / player.duration) * 100);
				}
				
				requestAnimationFrame(update_seek_bar_position);
			}
			requestAnimationFrame(update_seek_bar_position);

            // Extracts the raw audio samples from the given video file.
			//
			// Returns a Promise that resolves to an object of the following kind:
			//
			//     {
			//	       duration,
		    //         sampleRate,
			//         channels
			//         [
			//             Float32Array,
			//             Float32Array,
			//             ...
			//             Float32Array,
			//         ],
			//     }
			//
			// where 'duration' gives the audio's duration in seconds; 'sampleRate' the audio's sample
			// rate; and 'channels' an array of Float32Array objects, each giving the raw samples of a
			// particular channel of audio. (The audio's channel count is equal to channels.length.)
			//
			async function get_raw_audio(videoFile)
			{
				return new Promise((resolve)=>
				{
					const fileReader = new FileReader();

					fileReader.readAsArrayBuffer(videoFile);
					fileReader.onloadend = async()=>
					{
						const audioContext = new (window.AudioContext || window.webkitAudioContext)();
						const decodedAudioData = await audioContext.decodeAudioData(fileReader.result);

						const returnData =
						{
							duration: decodedAudioData.duration,
							sampleRate: decodedAudioData.sampleRate,
							channels: new Array(decodedAudioData.numberOfChannels).fill().map((elem, idx)=>decodedAudioData.getChannelData(idx)),
						}

						resolve(returnData);
					};
				});
			}

			// Finds samples in the audio whose magnitude exceeds a threshold. Returns a
			// list of these samples in an array of the following form:
			//
			//     [
			//	       {idx, sample},
			//         {idx, sample},
			//         ...
			//         {idx, sample},
			//     ]
			//
			// where 'idx' is the index of this sample in the audio, and 'sample' is the
			// value of that sample.
			//
			// The audio is expected to be provided as an array of samples, e.g. Float32Array.
			//
			function find_audio_peaks(audioSamples)
			{
				const [min, max, median] = (()=>
				{
					const median = audioSamples.slice().sort()[audioSamples.length / 2];
					let min = Number.MAX_SAFE_INTEGER;
					let max = Number.MIN_SAFE_INTEGER;

					for (let i = 0; i < audioSamples.length; i++)
					{
						const sample = Math.abs(audioSamples[i]);

						if (sample > max) max = sample;
						if (sample < min) min = sample;
					}

					return [min, max, median];
				})();

				return audioSamples.reduce((peaks, sample, idx)=>
				{
					if (Math.abs(sample) > ((max - min) * 0.4))
					{
						peaks.push({idx, sample});
					}

					return peaks;
				}, []);
			}

			function render_peaks_into_canvas(peaks, audioSampleSize)
			{
				const canvas = document.getElementById("audio-peaks-canvas");
				const context = canvas.getContext("2d");

				context.fillStyle = "goldenrod";

				for (let i = 0; i < peaks.length; i++)
				{
					const x = (peaks[i].idx / audioSampleSize) * canvas.width;
					context.fillRect(x, 0, x+1, canvas.height);
				}
			}
		</script>
	</body>
</html>
